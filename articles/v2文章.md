# mini Claude Code v2：让计划不再"隐形" -- TodoWrite 工具

v1 版本用 400 行代码证明了一件事：只要把大模型嵌入一个工具循环，它就能像助手一样在本地仓库里读写文件、执行命令。但当你让它处理稍微复杂一点的任务时，比如"重构认证模块，补充测试，更新文档"，一个严重问题暴露了：**模型的计划只存在于它的"脑子"里**。

```sh
v1 的工作方式:

  用户: "重构认证, 补测试, 更新文档"

  模型内心: "好, 我先做认证... 然后..."
  (10 轮工具调用后)
  模型内心: "等等, 我刚才做到哪了? 测试写了没?"
```

这不是模型笨。这是**上下文窗口的注意力稀释**。当对话历史塞满了文件内容、命令输出、中间思考，模型很难从几万 token 中精确回忆"我的计划是什么，进行到第几步了"。

人类面对同样的问题时怎么做？**写下来**。一张便利贴、一个清单、一块白板。把计划从脑子里搬到纸上。

v2 做的就是这件事：**给模型一支笔和一张便利贴**。

## 1. "Context Fade"：隐形计划的代价

先理解问题的本质。v1 中模型的规划方式是纯文本的"内心独白"：

```sh
Assistant: "好的, 我来分三步完成:
1. 重构 auth.py 的认证逻辑
2. 为新逻辑补充单元测试
3. 更新 README 文档

让我先开始第一步..."
```

这段文字进入对话历史后，会发生什么？

- 第 1-5 轮：模型还记得三步计划
- 第 6-15 轮：大量 read_file、bash 输出涌入，计划被淹没
- 第 16 轮以后：模型开始"即兴发挥"，可能重复已完成的工作，或跳过遗漏的步骤

这就是 Context Fade -- 计划信息随着对话推进而"褪色"。它不是被删除了，而是被稀释在了海量工具输出中，模型的注意力无法持续锁定在计划上。

## 2. TodoWrite 工具：把计划变成数据结构

v2 的核心创新只有一个东西：`TodoWrite` 工具。它不是一个执行动作的工具（不像 bash 执行命令、write_file 写文件），而是一个**管理状态的工具**。

```python
{
    "name": "TodoWrite",
    "description": "Update the task list. Use to plan and track progress.",
    "input_schema": {
        "type": "object",
        "properties": {
            "items": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "content": {"type": "string", "description": "Task description"},
                        "status": {
                            "type": "string",
                            "enum": ["pending", "in_progress", "completed"]
                        },
                        "activeForm": {
                            "type": "string",
                            "description": "Present tense action, e.g. 'Reading files'"
                        },
                    },
                    "required": ["content", "status", "activeForm"],
                },
            }
        },
        "required": ["items"],
    },
}
```

模型每次调用 TodoWrite 时，传入一个完整的任务列表。注意设计上的一个关键选择：**每次都是完整覆盖写入，而不是增量更新**。这意味着模型必须把所有任务（包括已完成的）一起传过来，迫使它在每次更新时重新审视完整计划。

## 3. TodoManager：约束即赋能

TodoManager 是维护任务列表的服务端类。它的代码不到 50 行，但每一个约束都有明确意图：

```python
class TodoManager:
    def __init__(self):
        self.items = []

    def update(self, items: list) -> str:
        validated = []
        in_progress_count = 0

        for i, item in enumerate(items):
            content = str(item.get("content", "")).strip()
            status = str(item.get("status", "pending")).lower()
            active_form = str(item.get("activeForm", "")).strip()

            if not content:
                raise ValueError(f"Item {i}: content required")
            if status not in ("pending", "in_progress", "completed"):
                raise ValueError(f"Item {i}: invalid status '{status}'")
            if not active_form:
                raise ValueError(f"Item {i}: activeForm required")

            if status == "in_progress":
                in_progress_count += 1

            validated.append({
                "content": content,
                "status": status,
                "activeForm": active_form
            })

        if len(validated) > 20:
            raise ValueError("Max 20 todos allowed")
        if in_progress_count > 1:
            raise ValueError("Only one task can be in_progress at a time")

        self.items = validated
        return self.render()
```

三个核心约束：

| 约束 | 规则 | 设计意图 |
|------|------|----------|
| 数量上限 | 最多 20 条 | 防止模型无限拆分，迫使它保持粒度适当 |
| 单一焦点 | 同一时刻只允许一个 in_progress | 防止模型"并行幻觉"，强制逐项推进 |
| 必填字段 | content + status + activeForm 缺一不可 | 确保计划结构化，不是随意的文字片段 |

其中 `activeForm` 字段值得单独说明。它是任务的**进行时态描述**：

- content = "Add unit tests" (祈使句，描述要做什么)
- activeForm = "Adding unit tests for auth module" (进行时态，描述正在做什么)

这不是冗余。当 render() 渲染列表时，in_progress 的任务会显示 activeForm：

```python
def render(self) -> str:
    if not self.items:
        return "No todos."

    lines = []
    for item in self.items:
        if item["status"] == "completed":
            lines.append(f"[x] {item['content']}")
        elif item["status"] == "in_progress":
            lines.append(f"[>] {item['content']} <- {item['activeForm']}")
        else:
            lines.append(f"[ ] {item['content']}")

    completed = sum(1 for t in self.items if t["status"] == "completed")
    lines.append(f"\n({completed}/{len(self.items)} completed)")

    return "\n".join(lines)
```

渲染结果像这样：

```sh
[x] Refactor auth module
[>] Add unit tests <- Adding unit tests for auth module...
[ ] Update documentation

(1/3 completed)
```

这段文本作为 tool_result 返回给模型。模型在下一轮对话中看到它，就知道：第一步已完成，当前正在做第二步，第三步还没开始。**计划从"隐形"变成了"可见"**。

## 4. 系统提醒机制：软约束引导行为

仅仅提供 TodoWrite 工具还不够。模型可能"忘记"使用它——毕竟它不是执行任务的必需工具。v2 引入了两层提醒机制：

```python
INITIAL_REMINDER = "<reminder>Use TodoWrite for multi-step tasks.</reminder>"
NAG_REMINDER = "<reminder>10+ turns without todo update. Please update todos.</reminder>"
```

**第一层：初始提醒**

会话开始时，在第一条 user message 中注入 INITIAL_REMINDER：

```python
if first_message:
    content.append({"type": "text", "text": INITIAL_REMINDER})
    first_message = False
```

这是一个温和的提示，告诉模型"这个环境中有 Todo 工具，请使用它"。

**第二层：懈怠提醒**

在 Agent Loop 内部，跟踪模型连续多少轮没有调用 TodoWrite：

```python
rounds_without_todo = 0

def agent_loop(messages: list) -> list:
    global rounds_without_todo

    while True:
        # ... API 调用和工具执行 ...

        if used_todo:
            rounds_without_todo = 0
        else:
            rounds_without_todo += 1

        # 连续 10 轮未更新 -> 注入提醒
        if rounds_without_todo > 10:
            results.insert(0, {"type": "text", "text": NAG_REMINDER})
```

当模型连续 10 轮没有更新 Todo，系统在下一轮的 tool_result 消息中插入 NAG_REMINDER。注意这个提醒被放在 tool_result 列表的**最前面**，确保模型优先看到。

这两层提醒都是**软约束**。它们不强制模型做任何事，只是在上下文中添加提示信息。对于简单的单步任务，模型可以完全忽略它们。但对于复杂的多步任务，这些提醒显著提高了模型使用 Todo 的概率。

## 5. 在 Agent Loop 中的位置

v2 的 Agent Loop 结构和 v1 基本相同，但在工具执行后增加了 Todo 使用跟踪：

```python
def agent_loop(messages: list) -> list:
    global rounds_without_todo

    while True:
        response = client.messages.create(
            model=MODEL, system=SYSTEM,
            messages=messages, tools=TOOLS, max_tokens=8000,
        )

        # ... 打印文本、收集工具调用 ...

        if response.stop_reason != "tool_use":
            messages.append({"role": "assistant", "content": response.content})
            return messages

        results = []
        used_todo = False

        for tc in tool_calls:
            output = execute_tool(tc.name, tc.input)
            results.append({
                "type": "tool_result",
                "tool_use_id": tc.id,
                "content": output,
            })

            if tc.name == "TodoWrite":
                used_todo = True

        # 跟踪 Todo 使用频率
        if used_todo:
            rounds_without_todo = 0
        else:
            rounds_without_todo += 1

        messages.append({"role": "assistant", "content": response.content})

        # 超过 10 轮未更新 -> 注入提醒
        if rounds_without_todo > 10:
            results.insert(0, {"type": "text", "text": NAG_REMINDER})

        messages.append({"role": "user", "content": results})
```

注意 NAG_REMINDER 的注入时机：它被插入到 `results` 列表（tool_result 消息）中，而不是创建一条新的 user message。这是因为 Anthropic API 要求 user/assistant 角色严格交替，提醒必须嵌在已有的 user message 里。

## 6. 典型工作流

```sh
用户: "帮我重构认证模块, 补充测试, 更新文档"

模型第 1 轮:
  > TodoWrite([
      {content: "重构认证模块", status: "in_progress", activeForm: "分析认证模块结构"},
      {content: "补充单元测试", status: "pending", activeForm: "编写测试用例"},
      {content: "更新 README", status: "pending", activeForm: "更新文档"}
    ])
  <- [>] 重构认证模块 <- 分析认证模块结构
     [ ] 补充单元测试
     [ ] 更新 README
     (0/3 completed)

模型第 2-8 轮:
  > read_file(auth.py)
  > edit_file(auth.py, ...)
  > bash("python -m pytest tests/test_auth.py")

模型第 9 轮:
  > TodoWrite([
      {content: "重构认证模块", status: "completed", activeForm: "重构认证模块"},
      {content: "补充单元测试", status: "in_progress", activeForm: "编写 auth 模块测试"},
      {content: "更新 README", status: "pending", activeForm: "更新文档"}
    ])
  <- [x] 重构认证模块
     [>] 补充单元测试 <- 编写 auth 模块测试
     [ ] 更新 README
     (1/3 completed)

模型第 10-15 轮: 编写测试...

模型第 16 轮:
  > TodoWrite([...第二项 completed, 第三项 in_progress...])
  <- [x] 重构认证模块
     [x] 补充单元测试
     [>] 更新 README <- 更新项目文档
     (2/3 completed)
```

每次 TodoWrite 调用后，模型在下一轮看到完整的进度快照。这形成了一个**自监督闭环**：模型更新计划 -> 看到更新后的状态 -> 根据状态决定下一步。

## 7. 背后的思想

> **结构化约束是一种赋能。**

这是 v2 最深层的洞察。TodoWrite 的三个约束看似是限制，实际上是在帮模型：

1. **可见性**

   计划从模型内部的隐式推理变成了对话历史中的显式数据结构。人类用白板管理项目，模型用 TodoWrite 管理任务。工具不同，原理相同：**外化认知负担**。

2. **约束驱动聚焦**

   "只能有一个 in_progress" 这条规则，表面上是限制，本质上是在帮模型做注意力管理。人类的工作记忆也只有 4-7 个槽位，多任务切换是生产力的大敌。强制单一焦点不是削弱能力，而是保护能力。

3. **自我监督循环**

   TodoWrite 的返回值（渲染后的文本）重新进入对话历史，模型能在下一轮"看到自己刚刚做的计划更新"。这类似于人类"写下来然后重新审视"的认知模式。写的动作本身就是思考的一部分。

4. **增量成本为零的规划**

   TodoWrite 不调用外部 API、不读写文件、不执行命令。它的"执行"就是一次列表验证和文本渲染。这意味着规划是免费的（相对于工具执行的 IO 成本），模型没有理由不做规划。

这个模式在 Agent 设计中反复出现：

- `max_tokens` 约束 -> 让模型输出更聚焦
- Tool schema 约束 -> 让工具调用结构化
- Todo 约束 -> 让任务执行有序化

**好的约束不是枷锁，是脚手架。**

## 8. 与 Claude Code 的对比

| 机制 | Claude Code | mini Claude Code v2 |
|------|-------------|---------------------|
| 工具名称 | TodoWrite | TodoWrite |
| 数据模型 | content + status + activeForm | 完全一致 |
| 更新方式 | 完整覆盖写入 | 完全一致 |
| 最大条目数 | 20 | 20 |
| in_progress 限制 | 最多 1 个 | 完全一致 |
| 渲染格式 | [x] / [>] / [ ] | 完全一致 |
| 提醒机制 | system-reminder 注入 | INITIAL + NAG 两层 |
| 与 Tasks 关系 | TodoWrite 后来被 Tasks 系统替代 | v6 引入 Tasks |

值得注意的是 TodoWrite 在后续版本中的命运：v6 引入了 Tasks 系统（TaskCreate, TaskUpdate, TaskList, TaskGet），通过 feature gate 将 TodoWrite 替换掉。原因是 TodoWrite 的数据存储在消息历史中，上下文压缩（v5）会把它一起清除。Tasks 系统用文件持久化解决了这个问题。但这不影响 v2 的教学价值 -- TodoWrite 是理解"结构化约束引导模型行为"的最佳入口。

## 9. 三部曲回顾

| 版本 | 核心主题 | 行数 | 关键洞察 |
|------|----------|------|----------|
| v1 | Model as Agent | ~200 行 | 模型是 80%，代码只是工具循环的载体 |
| **v2** | **结构化规划** | **~300 行** | **用约束引导模型行为，用可见性替代记忆** |
| v3 | 分而治之 | ~450 行 | 子代理隔离上下文，专注单一职责 |

v1 证明了模型能做事。v2 证明了模型能**有计划地**做事。从 v1 到 v2 只新增了一个工具和一个管理类，代码增量不到 170 行，但 Agent 的行为模式发生了质变：从"随机游走"变成了"按图索骥"。

---

**隐形的计划不是计划。可见的约束不是限制。TodoWrite 用最小的代价，让模型从"执行者"升级为"规划者"。**

完整代码见仓库 `v2_todo_agent.py`。
