# mini Claude Code v6：从便利贴到看板 -- Tasks 系统

v2 引入了 TodoWrite，让 Agent 学会了写计划。v5 引入了上下文压缩，让 Agent 能做无限长的任务。然后一个尴尬的事情发生了：**压缩把 TodoWrite 的计划一起压没了。**

```sh
压缩前:
  [...100 轮对话...]
  TodoWrite: [>] 修改认证模块  [>] 更新测试  [ ] 部署

压缩后:
  [摘要: "用户要求重构认证模块, 已修改 auth.py..."]
  (TodoWrite 的数据? 不存在了.)
```

这不是 bug，是架构缺陷。TodoWrite 的数据活在消息历史里，压缩清除了消息历史，任务清单就跟着消失了。

但问题不止于此。当你有了子代理（v3）、有了后台执行（即将在 v7 引入），新的需求出现了：

- 两个子代理同时修改同一个任务列表，数据会覆盖
- 子代理 A 完成的任务，子代理 B 看不到
- 任务之间没有依赖关系，"写 API 必须等数据库建好"这种约束无法表达

v6 用全新的 Tasks 系统替代了 TodoWrite。这不是升级，是**范式转变**。

## 1. 便利贴 vs 看板

把两个系统的差异想象成办公场景：

```sh
TodoWrite (便利贴):
  +-------------------+
  |  [ ] 买牛奶        |   一个人用
  |  [x] 交报告        |   写满了就换一张
  |  [ ] 修 bug        |   贴在自己桌上
  +-------------------+   丢了就没了

Tasks (项目看板):
  待做            进行中          已完成
  +-----------+  +-----------+  +-----------+
  | #3 写测试  |  | #2 写 API  |  | #1 建数据库|
  | blocked:#2 |  | @backend   |  | @analyst  |
  +-----------+  +-----------+  +-----------+
  所有人共享 / 有依赖关系 / 有负责人 / 持久化在磁盘上
```

便利贴够一个人用。但当项目有多个参与者、有前后依赖、需要跨越压缩存活，就需要一个系统化的看板。

## 2. Task 数据模型

```python
@dataclass
class Task:
    id: str              # 自增 ID: "1", "2", "3"
    subject: str         # 祈使句标题: "Fix auth bug"
    description: str     # 详细描述
    status: str = "pending"      # pending | in_progress | completed
    active_form: str = ""        # 进行时态: "Fixing auth bug"
    owner: str = ""              # 负责的代理名
    blocks: list = field(default_factory=list)     # 此任务阻塞了谁
    blocked_by: list = field(default_factory=list)  # 谁阻塞了此任务
```

每个字段都有明确的存在理由：

| 字段 | 为什么需要 |
|------|-----------|
| `id` | CRUD 操作需要唯一标识，不能再靠位置索引 |
| `owner` | 多个代理同时工作，得知道谁在做什么 |
| `blocks/blocked_by` | 依赖图让任务有先后顺序 |
| `description` | 另一个代理接手时能理解上下文 |
| `active_form` | 进行时态让状态面板更可读 |

## 3. 四个 CRUD 工具

TodoWrite 只有一个操作：整体覆盖写入。Tasks 拆分为四个原子操作。

```python
# TaskCreate: 创建任务
TaskCreate(subject="Set up database", description="Create PostgreSQL schema...")
# -> {"id": "1", "subject": "Set up database", "status": "pending"}

# TaskGet: 读取单个任务详情
TaskGet(taskId="1")
# -> {id, subject, description, status, owner, blocks, blocked_by}

# TaskUpdate: 原子更新
TaskUpdate(taskId="1", status="in_progress")           # 改状态
TaskUpdate(taskId="2", addBlockedBy=["1"])              # 添加依赖
TaskUpdate(taskId="1", owner="backend-agent")           # 分配负责人

# TaskList: 列出全部任务
TaskList()
# -> #1. [>] Set up database  @backend-agent
#    #2. [ ] Write API endpoints  (blocked by: #1)
#    #3. [ ] Write tests  (blocked by: #1, #2)
```

## 4. 依赖图的自动维护

依赖关系是双向的。当你声明"任务 2 被任务 1 阻塞"，系统自动在两端建立关联：

```python
def update(self, task_id: str, **kwargs) -> Task:
    task = self._load_task(task_id)

    if "addBlockedBy" in kwargs:
        for blocker_id in kwargs["addBlockedBy"]:
            if blocker_id not in task.blocked_by:
                task.blocked_by.append(blocker_id)
            # 同时更新另一端
            blocker_task = self._load_task(blocker_id)
            if blocker_task and task.id not in blocker_task.blocks:
                blocker_task.blocks.append(task.id)
                self._save_task(blocker_task)

    # 当任务完成时, 自动解除下游阻塞
    if kwargs.get("status") == "completed":
        self._clear_dependency(task.id)

    self._save_task(task)
    return task
```

这意味着当 #1 完成后，#2 的 `blocked_by` 列表自动清空 #1，#2 变为可执行：

```sh
执行前:
  #1. [>] Set up database
  #2. [ ] Write API endpoints  (blocked by: #1)
  #3. [ ] Write tests          (blocked by: #1, #2)

#1 完成后 (自动):
  #1. [x] Set up database
  #2. [ ] Write API endpoints                     <- blocked_by 已清除
  #3. [ ] Write tests          (blocked by: #2)   <- 只剩 #2
```

## 5. 文件持久化：为什么不用数据库

```python
class TaskManager:
    def __init__(self, tasks_dir: Path = None):
        self.tasks_dir = tasks_dir or TASKS_DIR
        self.tasks_dir.mkdir(exist_ok=True)
        self._lock = threading.Lock()
        self._counter = self._load_counter()

    def _save_task(self, task: Task):
        data = asdict(task)
        self._task_path(task.id).write_text(json.dumps(data, indent=2))

    def _load_task(self, task_id: str) -> Task:
        path = self._task_path(task_id)
        if not path.exists():
            return None
        return Task(**json.loads(path.read_text()))
```

每个任务是一个独立的 JSON 文件：

```sh
.tasks/
  task_1.json    # {"id": "1", "subject": "Set up database", ...}
  task_2.json    # {"id": "2", "subject": "Write API endpoints", ...}
  task_3.json    # {"id": "3", "subject": "Write tests", ...}
```

为什么用文件而不是 SQLite？三个理由：

1. **细粒度锁定**：一个文件一个任务，两个代理同时更新不同任务互不影响
2. **跨进程访问**：子代理可能在不同线程甚至进程中，文件系统是天然的 IPC
3. **人类可读**：调试时直接 `cat .tasks/task_1.json` 就能看到状态

## 6. 与压缩的协作

这是 Tasks 相比 TodoWrite 最大的结构性优势：

```sh
TodoWrite + 压缩:
  压缩前: [...100 条消息, 包含 todo 数据...]
  压缩后: [摘要] + [最近 5 条]
           ^-- todo 数据没了

Tasks + 压缩:
  压缩前: [...100 条消息...] + [.tasks/ 目录下 5 个 JSON 文件]
  压缩后: [摘要] + [最近 5 条]  + [.tasks/ 目录下 5 个 JSON 文件]
                                   ^-- 任务数据完整保留
```

压缩只影响消息历史。磁盘上的 `.tasks/` 目录不受任何影响。压缩后 Agent 调用 `TaskList()` 仍然能看到完整的任务状态。

## 7. Feature Gate：平滑过渡

v6 通过 feature gate 让 TodoWrite 和 Tasks 互斥：

```python
TASKS_ENABLED = True

if TASKS_ENABLED:
    ALL_TOOLS = BASE_TOOLS + [SUBAGENT_TOOL, SKILL_TOOL,
                              TASK_CREATE_TOOL, TASK_GET_TOOL,
                              TASK_UPDATE_TOOL, TASK_LIST_TOOL]
else:
    ALL_TOOLS = BASE_TOOLS + [TODO_TOOL, SUBAGENT_TOOL, SKILL_TOOL]
```

启用 Tasks 时，TodoWrite 工具从工具列表中移除，模型根本看不到它。这是最简单也最可靠的迁移策略。

## 8. 典型协作场景

```sh
用户: "帮我把项目从 REST 迁移到 GraphQL"

Agent (Team Lead):
  1. TaskCreate("Analyze REST endpoints")              -> #1
  2. TaskCreate("Design GraphQL schema")               -> #2
  3. TaskCreate("Implement resolvers")                  -> #3
  4. TaskCreate("Update frontend queries")              -> #4

  5. TaskUpdate(id="2", addBlockedBy=["1"])    # schema 依赖分析
  6. TaskUpdate(id="3", addBlockedBy=["2"])    # resolver 依赖 schema
  7. TaskUpdate(id="4", addBlockedBy=["3"])    # frontend 依赖 resolver

看板状态:
  #1. [ ] Analyze REST endpoints
  #2. [ ] Design GraphQL schema        (blocked by: #1)
  #3. [ ] Implement resolvers           (blocked by: #2)
  #4. [ ] Update frontend queries       (blocked by: #3)

Agent 按依赖顺序逐个执行...
  #1 完成 -> #2 解锁 -> #2 完成 -> #3 解锁 -> ...
```

当后续引入 Teammate（v8），不同的 Teammate 可以同时认领不被阻塞的任务，真正实现并行协作。

## 9. 更深的洞察：从清单到系统

TodoWrite 和 Tasks 的差异，本质上反映了两种不同的组织模式：

```sh
个人效率:
  一个人 + 便利贴 = 足够了
  关键是自我约束 (v2 的核心思想)

团队协作:
  多人 + 看板 = 必须的
  关键是信息共享 + 依赖追踪 (v6 的核心思想)
```

当 Agent 从单体变成群体（子代理、后台任务、Teammate），任务管理必须从"清单"进化为"系统"。这不是复杂度的增加，而是**协作维度的展开**。

一个有趣的类比：人类文明的发展也经历了同样的过程。个人用大脑记事，小团队用口头传达，大组织用制度和流程。工具进化的本质是信息共享方式的进化。

## 10. 与 Claude Code 的对比

| 机制 | Claude Code | mini Claude Code v6 |
|------|-------------|---------------------|
| 数据模型 | Task dataclass (id, subject, status, owner, blocks...) | 完全一致 |
| CRUD 工具 | TaskCreate, TaskGet, TaskUpdate, TaskList | 完全一致 |
| 依赖追踪 | addBlocks / addBlockedBy 双向维护 | 完全一致 |
| 持久化 | 文件系统 (.tasks/) | 完全一致 |
| 并发安全 | 文件锁 | threading.Lock |
| Feature Gate | tasks_v2 flag | TASKS_ENABLED 变量 |
| 与 TodoWrite 关系 | 互斥（feature gate） | 完全一致 |

---

**便利贴让一个人有条理，看板让一群人有秩序。**

完整代码见仓库 `v6_tasks_agent.py`。
